\documentclass{article}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{todonotes}
\usepackage{xspace}
\usepackage{tikz}
\usepackage{graphicx}

\title{Opal Semantics}
\author{Alex Renda}
\date{\today}

\newcommand{\skipcom}{\texttt{skip}}
\newcommand{\seqcom}[2]{#1;\ #2}
\newcommand{\ifcom}[3]{\texttt{if}\ #1\ \texttt{then}\ \{#2\}\ \texttt{else}\ \{#3\}}
\newcommand{\withcom}[2]{\texttt{with}\ #1\ \texttt{do}\ \{#2\}}
\newcommand{\atcom}[2]{\texttt{at}\ #1\ \texttt{do}\ \{#2\}}
\newcommand{\hypcom}[2]{#1\ :=\ \texttt{hyp}\ \{#2\}}
\newcommand{\commitcom}[1]{\texttt{commit}\ #1}
\newcommand{\handlecom}[6]{\texttt{handle}\ #1.#2\ := \textit{#3}\ \texttt{with}\ #4\ \texttt{merge}\ #5\ \texttt{in}\ \{#6\}} % TODO: this should specify variables
\newcommand{\opcom}[1]{\textit{#1}}
\newcommand{\bigcdot}{\raisebox{-0.75ex}{\scalebox{2}{$\cdot$}}}
\newcommand{\partialfunc}{\rightharpoonup}
\newcommand{\config}[1]{\langle #1 \rangle}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\onestep}[1]{\rightarrow_{#1}}
\newcommand{\bigstep}[1]{\rightarrow_{#1}}
\newcommand{\com}{C}
\newcommand{\bool}{B}
\newcommand{\imp}{\textsc{Imp}\xspace}
\newcommand{\opal}{$\textsc{Opa}\lambda$\xspace}

% thanks to https://tex.stackexchange.com/a/132790
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}

\begin{document}

\maketitle

\section{Description}

Tiny turing-incomplete language based on \imp with sexps:

\section{Grammar}

\begin{grammar}
<Com> ::= \skipcom
\alt \seqcom{\synt{Com}}{\synt{Com}}
\alt \ifcom{\synt{Bool}}{\synt{Com}}{\synt{Com}}
\alt \withcom{\synt{Node}}{\synt{Com}}
\alt \atcom{\synt{Node}}{\synt{Com}}
\alt \hypcom{\synt{World}}{\synt{Com}}
\alt \commitcom{\synt{World}}
\alt \handlecom{\synt{Node}}{\synt{Var}}{\synt{Op}}{\synt{Sexp}}{\synt{Sexp}}{\synt{Com}}
\alt <Op>

<Sexp> ::= $\varnothing$
\alt <Node>.<Var>
\alt ( <Sexp> . <Sexp> )

<Bool> ::= <Sexp> = <Sexp>
\alt <Sexp> $\in$ <Sexp>
\alt <Bool> $\land$ <Bool>
\alt <Bool> $\lor$ <Bool>
\alt \true
\alt \false

\end{grammar}

\subsection{Values}

\begin{grammar}
<SexpValue> ::= $\varnothing$
\alt ( <SexpValue> . <SexpValue> )

<BoolValue> ::= \true
\alt \false
\end{grammar}

\section{Typing Judgement}

Well-formedness conditions:
\begin{itemize}
\item all used operations are defined
\item all node/var accesses are defined
\item all node accesses are permissioned
\item all committed worlds are defined
\item worlds are committed at most once (affine types)
\end{itemize}

\subsection{Terminology}
\begin{tabular}{l c p{6.4cm}}
$\Sigma$ : & $2^{\synt{Node} \times \synt{Var}}$ & Set of variables in scope \\
$H$ : & $2^{\synt{Op}}$ & Set of handlers in scope \\
$\Pi$ : & $2^{\synt{Node}}$ & Set of nodes giving permission \\
$\Omega$ : & $2^{\synt{World}}$ & Set of worlds in scope
\end{tabular}

\subsection{Commands}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \skipcom : \Omega$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Omega, \Pi, \Sigma, H \vdash c_1 : \Omega'$}
\AxiomC{$\Omega', \Pi, \Sigma, H \vdash c_2 : \Omega''$}
\BinaryInfC{$\Omega, \Pi, \Sigma, H \vdash c_1 ; c_2 : \Omega''$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash b : \textsc{Bool}$}
\AxiomC{$\Omega', \Pi, \Sigma, H \vdash c_1 : \Omega'$}
\AxiomC{$\Omega', \Pi, \Sigma, H \vdash c_2 : \Omega''$}
\TrinaryInfC{$\Omega, \Pi, \Sigma, H \vdash \ifcom{b}{c_1}{c_2} : \Omega$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Omega, \Pi, \Sigma, H \vdash c : \Omega''$}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \hypcom{u}{c} : \Omega \cup \{u\}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$u \in \Omega$}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \commitcom{u} : \Omega \setminus \{u\}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \in \Pi$}
\AxiomC{$\Sigma \vdash s_1 : \textsc{Sexp}$}
\AxiomC{$\Sigma \vdash s_2 : \textsc{Sexp}$}
\AxiomC{$\varnothing, \Pi, \Sigma \cup \{(n, v)\}, H \cup \{op\} \vdash c : \Omega'$}
\QuaternaryInfC{$\Omega, \Pi, \Sigma, H \vdash \handlecom{n}{v}{op}{s_1}{s_2}{c} : \Omega$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$op \in H$}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \opcom{op} : \Omega$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Omega, \Pi \cup \{n\}, \Sigma, H \vdash c : \Omega'$}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \withcom{n}{c} : \Omega'$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Omega, \Pi, \Sigma, H \vdash c : \Omega'$}
\UnaryInfC{$\Omega, \Pi, \Sigma, H \vdash \atcom{n}{c} : \Omega'$}
\end{prooftree}

\subsection{Booleans}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Sigma \vdash \true : \textsc{Bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Sigma \vdash \false : \textsc{Bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash b_1 : \textsc{Bool}$}
\AxiomC{$\Sigma \vdash b_2 : \textsc{Bool}$}
\BinaryInfC{$\Sigma \vdash b_1 \land b_2 : \textsc{Bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash b_1 : \textsc{Bool}$}
\AxiomC{$\Sigma \vdash b_2 : \textsc{Bool}$}
\BinaryInfC{$\Sigma \vdash b_1 \lor b_2 : \textsc{Bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash s_1 : \textsc{Sexp}$}
\AxiomC{$\Sigma \vdash s_2 : \textsc{Sexp}$}
\BinaryInfC{$\Sigma \vdash s_1 = s_2 : \textsc{Bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash s_1 : \textsc{Sexp}$}
\AxiomC{$\Sigma \vdash s_2 : \textsc{Sexp}$}
\BinaryInfC{$\Sigma \vdash s_1 \in s_2 : \textsc{Bool}$}
\end{prooftree}

\subsection{Sexps}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Sigma \vdash \varnothing : \textsc{Sexp}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$(n, v) \in \Sigma$}
\UnaryInfC{$\Sigma \vdash n.v : \textsc{Sexp}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Sigma \vdash s_1 : \textsc{Sexp}$}
\AxiomC{$\Sigma \vdash s_2 : \textsc{Sexp}$}
\BinaryInfC{$\Sigma \vdash (s_1 . s_2) : \textsc{Sexp}$}
\end{prooftree}


\section{Small Step Semantics}
\subsection{Terminology}

\begin{tabular}{l c p{6.4cm}}
$\sigma$ : & $\synt{Node} \times \synt{Var} \partialfunc \synt{SexpValue}$ & function representing each node's store \\\\
$\Sigma$ : & $\bigcdot \ \ |\ \ (\sigma, \Sigma)$ & stack of stores (for \textsc{Hyp} and \textsc{At}) \\\\
$\omega$ : & $\synt{World} \partialfunc (\Sigma \times \sigma)$ & function representing each world's initial stack and final store \\\\
$\pi$ : & $2^{\synt{Node}}$ & current authorized set of principals \\\\
$\rho$ : & $\synt{Node}$ & current execution location \\\\
$\eta$ : & $\synt{Op} \partialfunc (\synt{Node} \times \synt{Var} \times \synt{Sexp})$ & mapping of handlers to their destinations and expressions \\\\
$\mu$ : & $(\synt{Node} \times \synt{Var}) \partialfunc \synt{Sexp}$ & mapping of handler results to their merge expressions \\\\
$\Downarrow_{\synt{Com}}$ : & $(\synt{Com} \times \Sigma \times \omega \times \pi \times \rho \times \eta \times \mu) \partialfunc (\sigma \times \omega)$  & Commands step to a new top-level store and new set of hypothetical worlds\\\\
$\Downarrow_{\synt{Sexp}}$ : & $(\synt{Sexp} \times \Sigma \times \pi) \partialfunc \synt{SexpValue}$ & Sexps step to a value, or nothing if it cannot be evaluated due to undefined variables or lack of permission \\\\
$\Downarrow_{\synt{Bool}}$ : & $(\synt{Bool} \times \Sigma \times \pi) \partialfunc \synt{BoolValue}$ & Bools step to a value, or nothing if it cannot be evaluated due to undefined variables or lack of permission \\\\
\end{tabular}

\subsection{Basic commands}
\begin{prooftree}
\AxiomC{}
\RightLabel{$\textsc{Skip}$}
\UnaryInfC{$\config{\skipcom, (\sigma, \Sigma), \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma, \omega}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\config{c_1, (\sigma, \Sigma), \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\AxiomC{$\config{c_2, (\sigma', \Sigma), \omega', \pi, \rho, \eta, \mu} \Downarrow \config{\sigma'', \omega''}$}
\RightLabel{$\textsc{Seq}$}
\BinaryInfC{$\config{\seqcom{c_1}{c_2}, (\sigma, \Sigma), \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma'', \omega''}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\config{b, \Sigma, \pi} \Downarrow \true$}
\AxiomC{$\config{c_1, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{If-True}$}
\BinaryInfC{$\config{\ifcom{b}{c_1}{c_2}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\config{b, \Sigma, \pi} \Downarrow \false$}
\AxiomC{$\config{c_2, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{If-False}$}
\BinaryInfC{$\config{\ifcom{b}{c_1}{c_2}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\end{prooftree}

\subsection{Distribution commands}
In this semantics, \textsc{At} is effectively a noop/passthrough, resulting in behavior that would be identical with or without it (modulo endorsement taking location into account). It does have real-world semantics though: \textsc{At} represents executing a command on another computer, starting with a new empty store on the top of the stack, and shipping back the new store at the end. Beyond this, exact semantics are implementation dependent. An implementation could, in theory, send the entire stack of stores over in addition to just the command. Alternatively, the new machine could request any specific variables it needs, to mitigate the amount of data shuttled over the network.


\textsc{With} is also a passthrough in a similar regard: its runtime effects consist of asking the specified user for permission to run the specified command on the current machine (represented by $\config{n, \rho, c}\ \checkmark$ in the semantics -- the details of this function are implementation dependent).

\begin{prooftree}
\AxiomC{$\config{c, (\sigma_\varnothing, (\sigma, \Sigma)), \omega, \pi, n, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{At}$}
\UnaryInfC{$\config{\atcom{n}{c}, (\sigma, \Sigma), \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma';\sigma, \omega'}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\config{n, \rho, c}\ \checkmark$}
\AxiomC{$\config{c, \Sigma, \omega, \pi \cup \{n\}, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{With}$}
\BinaryInfC{$\config{\atcom{n}{c}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\end{prooftree}

\subsection{Handler commands}
We describe handlers as a tuple of $(\synt{Node}, \synt{Var}, \synt{Op}, \synt{Sexp}_h, \synt{Sexp}_m, \synt{Com})$, where $\synt{Node}$ is the node to write results to, $\synt{Var}$ is the variable on that node to write results to, $\synt{Op}$ is the name of the handler, $\synt{Sexp}_h$ is a sexp that gets lazily evaluated with its results written to $\synt{Node}.\synt{Var}$ each time $\synt{Op}$ is called, and $\synt{Sexp}_m$ is a sexp that gets lazily evaluated upon merge conflicts within a variable upon \texttt{commit}ing a hypothetical world, with $\varnothing.\textsc{Orig}$ set to the original value of the variable before the hypothetical execution, $\varnothing.\textsc{Hyp}$ set to the value of the variable after the hypothetical execution, and $\varnothing.\textsc{Curr}$ set to the value of the variable in the context of where $\texttt{commit}$ is being called.

\begin{prooftree}
\AxiomC{$\config{c, \Sigma, \omega, \pi, \rho, \eta[op \mapsto (n, v, s_h)], \mu[(n, v) \mapsto s_m]} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{Handle}$}
\UnaryInfC{$\config{\handlecom{n}{v}{op}{s_h}{s_m}{c}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\eta(op) = (n, v, s_h)$}
\AxiomC{$\config{s_h, \Sigma, \pi} \Downarrow s$}
\AxiomC{$n \in \pi$}
\RightLabel{$\textsc{Op}$}
\TrinaryInfC{$\config{\opcom{op}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma[(n, v) \mapsto s], \omega}$}
\end{prooftree}

\subsection{Hypothetical commands}

\begin{prooftree}
\AxiomC{$\config{c, (\sigma_\varnothing, \Sigma), \omega_\varnothing, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega'}$}
\RightLabel{$\textsc{Hyp}$}
\UnaryInfC{$\config{\hypcom{u}{c}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\dots, \omega[u \mapsto (\Sigma, \sigma)]}$}
\end{prooftree}

% proof that commits outside of "with" don't give any additional power that you shouldn't have
% proof of that is the fact that it's in a store in the first place

% poof idea: hyp movement to commit + hyp noninterference

% separate idea: mutually distrustful users that will only disclose if they both agree: 2-deep hyp execution (hyp without "with" internally)

\begin{prooftree}
\AxiomC{$\omega(u) = (\Sigma_{\texttt{orig}}, \sigma_{\texttt{hyp}})$}
\AxiomC{$\forall (n, v, s) \in \sigma_{\texttt{hyp}}. \config{\mu((n, v)), \Sigma[], \pi} \Downarrow s_f \Rightarrow \sigma'((n, v)) = s_f$}
\RightLabel{$\textsc{Commit}$}
\BinaryInfC{$\config{\commitcom{u}, \Sigma, \omega, \pi, \rho, \eta, \mu} \Downarrow \config{\sigma', \omega}$}
\end{prooftree}


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
